# M1.7 - End-to-End Validation

## Task Description

**What**: Verification that the complete flow works: speak → understand → remember → respond.

**Why**:
- Integration issues only appear when pieces connect
- Validates the core value proposition actually works
- Provides baseline for regression testing

## TDD Requirements

### Test File: `tests/test_e2e.py`

Write these tests FIRST:

```python
import pytest
from playwright.sync_api import Page, expect

@pytest.mark.e2e
def test_voice_conversation_flow(page: Page):
    """Complete voice conversation works end-to-end."""
    page.goto("http://localhost:5173")

    # 1. Verify initial state
    expect(page.locator("[data-testid='status-indicator']")).to_have_text("Ready")

    # 2. Start voice interaction
    page.click("[data-testid='mic-button']")

    # 3. Wait for response (status should cycle through Listening -> Thinking -> Speaking)
    page.wait_for_selector("[data-testid='status-indicator']:has-text('Speaking')", timeout=30000)

    # 4. Verify response completed
    page.wait_for_selector("[data-testid='status-indicator']:has-text('Ready')", timeout=30000)

@pytest.mark.e2e
def test_memory_persists_across_sessions(page: Page):
    """Memories persist across page reloads."""
    page.goto("http://localhost:5173")

    # Start session 1 - tell JARVIS something
    page.click("[data-testid='mic-button']")
    # (In real test, would need to send audio or use text fallback)

    # Reload page (new session)
    page.reload()

    # Verify connection restored
    page.wait_for_selector("[data-testid='connection-status']:has-text('Connected')")

    # Memory should still be accessible via API
    # (Test via backend API call)

@pytest.mark.e2e
def test_interruption_stops_response(page: Page):
    """User can interrupt JARVIS mid-response."""
    page.goto("http://localhost:5173")

    # Start a conversation that will generate a long response
    page.click("[data-testid='mic-button']")

    # Wait for response to start
    page.wait_for_selector("[data-testid='status-indicator']:has-text('Speaking')")

    # Interrupt by clicking mic again
    page.click("[data-testid='mic-button']")

    # Status should change to Listening (not Speaking)
    expect(page.locator("[data-testid='status-indicator']")).to_have_text("Listening")

@pytest.mark.e2e
def test_error_recovery(page: Page):
    """System recovers gracefully from errors."""
    page.goto("http://localhost:5173")

    # Simulate network error by going offline
    page.context.set_offline(True)

    # Try to interact
    page.click("[data-testid='mic-button']")

    # Should show error state, not crash
    error_indicator = page.locator("[data-testid='error-message']")
    expect(error_indicator).to_be_visible()

    # Go back online
    page.context.set_offline(False)

    # Should recover
    page.wait_for_selector("[data-testid='connection-status']:has-text('Connected')", timeout=10000)
```

## Verification Command

```bash
pytest tests/test_e2e.py -v -m e2e --browser chromium
```

## Completion Promise

Only output this when ALL tests pass:

```
<promise>M1.7 COMPLETE</promise>
```

## Dependencies

- M1.3 (Voice Loop)
- M1.4 (Memory Integration)
- M1.5 (Web Interface)

## Files to Create/Modify

- `tests/test_e2e.py`
- May need to add test utilities or fixtures

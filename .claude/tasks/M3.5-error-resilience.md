# M3.5 - Error Resilience

## Task Description

**What**: Graceful handling of failures in external services.

**Why**:
- AI APIs have rate limits and outages
- Network requests fail sometimes
- Users shouldn't see cryptic error messages

## TDD Requirements

### Test File: `tests/test_errors.py`

Write these tests FIRST:

```python
import pytest
from unittest.mock import patch, AsyncMock
from app.core.resilience import RetryHandler, CircuitBreaker

def test_retry_on_transient_failure():
    """Retries on transient failures."""
    handler = RetryHandler(max_retries=3, backoff_base=0.1)

    call_count = 0
    def flaky_function():
        nonlocal call_count
        call_count += 1
        if call_count < 3:
            raise ConnectionError("Transient failure")
        return "success"

    result = handler.execute(flaky_function)

    assert result == "success"
    assert call_count == 3

def test_gives_up_after_max_retries():
    """Gives up after max retries exceeded."""
    handler = RetryHandler(max_retries=3, backoff_base=0.1)

    def always_fails():
        raise ConnectionError("Always fails")

    with pytest.raises(ConnectionError):
        handler.execute(always_fails)

def test_circuit_breaker_opens():
    """Circuit breaker opens after repeated failures."""
    breaker = CircuitBreaker(failure_threshold=3, reset_timeout=1)

    def always_fails():
        raise Exception("Fail")

    # Fail enough times to open circuit
    for _ in range(3):
        try:
            breaker.execute(always_fails)
        except:
            pass

    # Circuit should be open now
    assert breaker.state == "open"

    # Should raise immediately without calling function
    with pytest.raises(Exception, match="Circuit breaker is open"):
        breaker.execute(always_fails)

def test_user_friendly_error_messages():
    """Errors are converted to user-friendly messages."""
    from app.core.errors import format_user_error

    # API timeout
    msg = format_user_error(TimeoutError("Connection timed out"))
    assert "try again" in msg.lower()
    assert "timed out" not in msg.lower()  # Don't expose technical detail

    # Rate limit
    msg = format_user_error(Exception("429 Too Many Requests"))
    assert "moment" in msg.lower() or "busy" in msg.lower()

@pytest.mark.asyncio
async def test_gemini_failure_fallback():
    """Graceful fallback when Gemini unavailable."""
    from app.core.voice_loop import VoiceLoop

    with patch("google.genai.Client") as mock_client:
        mock_client.return_value.aio.live.connect.side_effect = Exception("API Error")

        loop = VoiceLoop(model="test")
        response = await loop.handle_error(Exception("API Error"))

        assert "sorry" in response.lower() or "trouble" in response.lower()

@pytest.mark.asyncio
async def test_memory_failure_continues():
    """Conversation continues when memory unavailable."""
    from app.core.conversation import process_with_memory

    with patch("app.core.memory_client.MemoryClient.search") as mock_search:
        mock_search.side_effect = ConnectionError("Memory API down")

        # Should still work, just without memory context
        response = await process_with_memory("Hello", user_id="test")

        assert response is not None  # Didn't crash
```

## Verification Command

```bash
pytest tests/test_errors.py -v
```

## Completion Promise

Only output this when ALL tests pass:

```
<promise>M3.5 COMPLETE</promise>
```

## Dependencies

- M3.3 (Tool Integration)
- M3.4 (Memory Transparency)

## Files to Create/Modify

- `backend/app/core/resilience.py` - RetryHandler and CircuitBreaker
- `backend/app/core/errors.py` - format_user_error function
- Update `backend/app/core/conversation.py` - process_with_memory
- `tests/test_errors.py`

# M1.3 - Voice Conversation Loop

## Task Description

**What**: Integration with Gemini 2.5 Native Audio for real-time voice conversation.

**Why**:
- Single model pipeline = lower latency than STT → LLM → TTS chain
- Native audio understanding captures tone, emphasis, emotion
- Interruption support requires model to handle partial inputs

## TDD Requirements

### Test File: `tests/test_voice_loop.py`

Write these tests FIRST (based on Gemini Live API docs):
Audio format: 16-bit PCM, 16kHz mono input, 24kHz output

```python
import pytest
from unittest.mock import AsyncMock, patch
from app.core.voice_loop import VoiceLoop, AudioConfig

def test_audio_config_defaults():
    """Audio config matches Gemini requirements."""
    config = AudioConfig()
    assert config.input_sample_rate == 16000  # 16kHz input
    assert config.output_sample_rate == 24000  # 24kHz output
    assert config.channels == 1  # Mono
    assert config.format == "int16"  # 16-bit PCM

def test_voice_loop_initializes_with_model():
    """Voice loop requires model specification."""
    loop = VoiceLoop(model="gemini-2.5-flash-preview-native-audio-dialog")
    assert loop.model is not None

@pytest.mark.asyncio
async def test_voice_loop_connects_to_gemini():
    """Voice loop establishes connection to Gemini API."""
    with patch("google.genai.Client") as mock_client:
        mock_session = AsyncMock()
        mock_client.return_value.aio.live.connect.return_value.__aenter__.return_value = mock_session

        loop = VoiceLoop(model="gemini-2.5-flash-preview-native-audio-dialog")
        await loop.connect()

        mock_client.return_value.aio.live.connect.assert_called_once()

@pytest.mark.asyncio
async def test_voice_loop_sends_audio_chunk():
    """Voice loop can send audio to Gemini."""
    with patch("google.genai.Client") as mock_client:
        mock_session = AsyncMock()
        mock_client.return_value.aio.live.connect.return_value.__aenter__.return_value = mock_session

        loop = VoiceLoop(model="gemini-2.5-flash-preview-native-audio-dialog")
        await loop.connect()

        # 16-bit PCM audio chunk
        audio_chunk = bytes(1024)
        await loop.send_audio(audio_chunk)

        mock_session.send_realtime_input.assert_called()

def test_voice_loop_validates_audio_format():
    """Voice loop rejects invalid audio format."""
    loop = VoiceLoop(model="gemini-2.5-flash-preview-native-audio-dialog")

    # Wrong sample rate should raise
    with pytest.raises(ValueError, match="sample rate"):
        loop.validate_audio_format(sample_rate=44100, channels=1, format="int16")
```

## Verification Command

```bash
pytest tests/test_voice_loop.py -v
```

## Completion Promise

Only output this when ALL tests pass:

```
<promise>M1.3 COMPLETE</promise>
```

## Dependencies

- M1.2 (WebSocket Backend)

## Files to Create/Modify

- `backend/app/core/voice_loop.py` - VoiceLoop and AudioConfig classes
- `tests/test_voice_loop.py`
